name: Build and Deploy Static Assets
on:
  schedule:
    # use a site like https://crontab.guru/ to help develop this schedule if it needs changing
    - cron: '0 */1 * * *'
    - cron: '0 */2 * * *'
  workflow_dispatch:
    inputs:
      version:
        description: 'The branch, tag or SHA to checkout'
        required: true
        default: main
      environment:
        type: environment
        required: true
        description: 'environment to run'
        default: nonprod

env:
  build_path: public/pp_fonts

jobs:
  strategy:
    runs-on: ubuntu-latest
    outputs:
      run_env: ${{ steps.setenv.outputs.run_env }}
    strategy:
      matrix:
        environment:
          - name: 'nonprod'
            condition: ${{ github.event.schedule == '0 */2 * * *' }}
          - name: 'prod'
            condition: ${{ github.event.schedule == '0 */1 * * *' }}            
          - name: ${{ github.event.inputs.environment }}
            condition: ${{ github.event_name == 'workflow_dispatch' }}      
    steps:
      - name: Set Environment Name
        id: setenv
        run: |
          if ${{ matrix.environment.condition }}; then
            echo "run_env=${{ matrix.environment.name }}" >> $GITHUB_OUTPUT
          fi
      - name: Print Environment Name
        run: |
          echo "Executing in the environment '${{ steps.setenv.outputs.run_env }}'"

  build:
    runs-on: ubuntu-latest
    needs: strategy
    environment: ${{ needs.strategy.outputs.run_env }}
    steps:
      - name: Print Environment Name
        run: |
          echo "Executing against '${{ needs.strategy.outputs.run_env }}' SITECORE environment"
      - name: Checkout 🛎️
        uses: actions/checkout@v3
      - name: Download JSON files asynchronously
        shell: bash
        run: |
          SITECORE_URL=${{vars.SITECORE_URL}}
          SITECORE_API_KEY=${{secrets.SITECORE_API_KEY}}
          url="https://$SITECORE_URL/sitecore/api/layout/render/jss?item=/"
          suffix="&sc_lang=en&sc_apikey=%7B$SITECORE_API_KEY%7D"
          rootDir="jss"
          
          uris=(
            'california-privacy-law'
            'resources/accessibility'
            'resources/bill-redesign'
            'resources/emergency-preparation'
            'resources/movers'
          )

          jobs=()
          for uri in "${uris[@]}"; do
            (
              request_uri="$url$uri$suffix"
              response=$(curl -s -w "\n%{http_code}" $request_uri -H "Cache-Control: no-cache, no-store")
              response=(${response[@]}) # convert to array
              code=${response[-1]} # get last element (last line)
              body=${response[@]::${#response[@]}-1} # get all elements except last
              name=$(echo $body | jq '.name')

              if [ $? -eq 0 ] && [ $code == "200" ]; then
                inputString="$uri"
                elements=($inputString)
                folderPath="$rootDir"

                # Loop through the elements and create folders
                for i in "${!elements[@]}"; do
                  folderPath="$folderPath/${elements[i]}"
                  mkdir -p "$folderPath"
                done

                filename="${elements[-1]}.json"
                echo "$body" | jq '.' > "$rootDir/$filename"
              else
                echo "ERROR: Unexpected response status code: '$code'."
                exit 1
              fi
            ) &
            jobs+=("$!")
          done

          # Wait for all jobs to complete
          for job in "${jobs[@]}"; do
            wait "$job"
          done
      - name: Download Images
        shell: bash
        run: |
          SITECORE_URL=${{vars.SITECORE_CDN}}
          url="https://$SITECORE_URL/-/jssmedia/Project/Frontier/Dotcom/Images/"
          rootDir="cdn_images"
          
          uris=(
            '5-gig/updated/fiber-5-gig-q4-refresh-desktop.png'
            '5-gig/updated/fiber-5-gig-q4-refresh-mobile.png'
          )

          jobs=()
          for uri in "${uris[@]}"; do
            (
              request_uri="$url$uri"
              # Extract the directory and filename from the URL
              directory=$(dirname "${uri}")
              filename=$(basename "${uri}" | awk -F '?' '{print $1}')
          
              # Create the directory structure if it doesn't exist
              mkdir -p "${rootDir}/${directory}"
              curl -o "${rootDir}/${directory}/${filename}" "${request_uri}" -H "Cache-Control: no-cache, no-store"
            ) &
            jobs+=("$!")
          done

          # Wait for all jobs to complete
          for job in "${jobs[@]}"; do
            wait "$job"
          done
      - name: Copy public files
        run: |
          cp jss public/pp_fonts/ -r
          cp cdn_images public/pp_fonts/ -r
          cp public/css/font-loader.css public/pp_fonts/
          cp public/css/font-lazy.css public/pp_fonts/
          cp public/js/at.js public/pp_fonts/
      - name: Archive build artifacts
        uses: actions/upload-artifact@v3
        with:
          name: fuel-homepage-build
          path: |
            ${{ env.build_path }}
  
  manage_infrastructure:
    runs-on: ubuntu-latest
    needs: strategy
    environment: ${{ needs.strategy.outputs.run_env }}
    defaults:
      run:
        working-directory: ./terraform/assets
    env:
      TF_WORKSPACE: "fuel-homepage-assets-${{ needs.strategy.outputs.run_env }}"
      TF_IN_AUTOMATION: true
    steps:
    - name: Checkout 🛎️
      uses: actions/checkout@v3
    - name: Setup Terraform     
      uses: hashicorp/setup-terraform@v2
      with:
        cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}
    - name: Azure login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
    - name: Terraform Init
      id: init
      run: terraform init
    - name: Terraform Apply
      id: apply
      run: terraform apply -var environment=${{ needs.strategy.outputs.run_env }} -input=false -auto-approve
    - name: Azure logout
      if: always()
      run: az logout
      shell: bash

  upload_artifact:
    runs-on: ubuntu-latest
    env:
      azure_bucket: fuelpageassets${{ needs.strategy.outputs.run_env }}
    environment: ${{ needs.strategy.outputs.run_env }}
    needs: [strategy, build, manage_infrastructure]
    steps:
    - name: Download build artifact
      uses: actions/download-artifact@v3
      with:
        name: fuel-homepage-build
        path: ./${{ env.build_path }}
    - name: Azure login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
    - name: 🔎 Check IP
      run: curl https://api.ipify.org
      shell: bash
    - name: Define IP address
      id: ip
      run: |
        sleep 5
        ip=`dig +short myip.opendns.com @resolver1.opendns.com`
        echo "address=$ip" >> $GITHUB_OUTPUT
      shell: bash

    - name: Add network rule to storage account
      id: addnetworkrule
      run: |
        try {
          $Error.Clear()
          [Int32]$Retries = 24
          [Int32]$SecondsDelay = 10
          [Int32]$retrycount = 0
          [Bool]$completed = $false          
          $command = "(az storage account network-rule add --account-name `"${{ env.azure_bucket }}`" --ip-address `"${{ steps.ip.outputs.address }}`") 2>&1"
          Write-Output "Executing command: '$command'"

          while (-not $completed) {
            $Error.Clear()
            $result = Invoke-Expression -Command $command
            if ($LastExitCode -ne 0) {
              if ($retrycount -ge $Retries) {
                $myMsg = "Command exit code '$LastExitCode' and result: '$result'"
                Throw $myMsg
              } else {
                $myMsg = "Command exit code '$LastExitCode' and result: '$result'"
                Write-Output "$myMsg`r`n`tRetrying in '$SecondsDelay' seconds"
                Start-Sleep $SecondsDelay
                $retrycount++
                Write-Output "---------------------RETRY #($retrycount)-----------------------------------"
                continue
              }
            } else {
              Write-Output "Command succeeded"
              Write-Output "Let's wait for 30 seconds for Azure to refresh white listed IP..."
              Start-Sleep -s 30
              $completed = $true
            } 
          }
        } catch {
          Write-Error "[ERR] Error happened while adding network rule to storage account. Details: '$_'"
        } finally {
          $Error.Clear()
        }
      shell: pwsh 

    - name: Print logs for troubleshooting
      if: steps.addnetworkrule.outcome == 'success'
      run: |
        try {
          $Error.Clear()
          [Bool]$completed = $false          
          Write-Output "Listing Network rules"
          Invoke-Expression -Command "az storage account network-rule list --account-name `"${{ env.azure_bucket }}`" | Select-String -Pattern ${{ steps.ip.outputs.address }} -SimpleMatch"
          Write-Output "Command executed"
        } catch {
          Write-Error "[ERR] Error happened while printing logs. Details: '$_'"
        } finally {
          $Error.Clear()
        }
      shell: pwsh 

    - name: Upload artifact to storage
      if: steps.addnetworkrule.outcome == 'success'
      run: |
        try {
          $Error.Clear()
          [Int32]$Retries = 24
          [Int32]$SecondsDelay = 10
          [Int32]$retrycount = 0
          [Bool]$completed = $false 
          $command = "(az storage blob upload-batch --account-name `"${{ env.azure_bucket }}`" --destination `"```$web`" --source `"./${{ env.build_path }}`" --auth-mode key --overwrite=True --only-show-errors) 2>&1"
          Write-Output "Executing command: '$command'"
          while (-not $completed) {
            [String]$errorString = ""
            [String]$warningString = ""
            [Bool]$bError = $false
            [Bool]$bWarning = $false
            [Bool]$errDetector = $false
            [Bool]$warDetector = $false
            $Error.Clear()
            $result = Invoke-Expression -Command $command
            $resultExitCode = $LastExitCode
            Write-Output "Command finished with the following error code: '$resultExitCode'"
            $outputStream = $result | Where-Object { $_ -is [System.Management.Automation.ErrorRecord] }
            if ($resultExitCode -ne 0) {
              $outputStream | ForEach-Object { 
                if ($_.ToString().StartsWith("ERROR: ")) {
                  if ($errorString.Length -gt 0) { $errorString += "`n" }
                  $bError = $true
                  $errDetector = $true
                  $bWarning = $false
                }
                if ($_.ToString().StartsWith("WARNING: ")) {
                  if ($warningString.Length -gt 0) { $warningString += "`n" }  
                  $bWarning = $true
                  $warDetector = $true
                  $bError = $false
                }
                if ($bError) {
                  $errorString += $_.ToString() + " "
                }
                if ($bWarning) {
                  $warningString += $_.ToString() + " "
                }
              }

              # Output errors and warings
              if ($errDetector) {
                Write-Output "Following Errors detected:`r`n`t$errorString"
              }
              if ($warDetector) {
                Write-Output "Following Warnings detected:`r`n`t$warningString"
              }

              # Need to retry only when ERROR detected; no need to retry in the case of WARNINGS only in the output stream
              if ($errDetector -or ($resultExitCode -ne 0)) {
                if ($retrycount -ge $Retries) {
                  $myMsg = "Failed to successfully execute command with all retry commands exhausted"
                  Throw $myMsg
                } else {
                  Write-Output "`r`n`tRetrying in '$SecondsDelay' seconds"
                  Start-Sleep $SecondsDelay
                  $retrycount++
                  Write-Output "---------------------RETRY #($retrycount)-----------------------------------"
                  continue
                }
              }
            }
            Write-Output "Command succeeded"
            $completed = $true
          }
        } catch {
          Write-Error "[ERR] Error happened while uploading batch to storage account. Details: '$_'"
        } finally {
          $Error.Clear()
        }

        # -----------------------------------------------------

        try {
          $Error.Clear()
          [Int32]$Retries = 24
          [Int32]$SecondsDelay = 10
          [Int32]$retrycount = 0
          [Bool]$completed = $false 
          $date = (Get-Date).ToUniversalTime().ToString('yyyy-MM-ddTHH:mmZ')
          $command = "(az storage blob delete-batch --account-name `"${{ env.azure_bucket }}`" --source `"```$web`" --if-unmodified-since `"$date`" --pattern `"${{ env.build_path }}/*`" --auth-mode key --only-show-errors) 2>&1"
          Write-Output "Executing command: '$command'"
          while (-not $completed) {
            [String]$errorString = ""
            [String]$warningString = ""
            [Bool]$bError = $false
            [Bool]$bWarning = $false
            [Bool]$errDetector = $false
            [Bool]$warDetector = $false
            $Error.Clear()
            $result = Invoke-Expression -Command $command
            $resultExitCode = $LastExitCode
            Write-Output "Command finished with the following error code: '$resultExitCode'"
            $outputStream = $result | Where-Object { $_ -is [System.Management.Automation.ErrorRecord] }
            if ($resultExitCode -ne 0) {
              $outputStream | ForEach-Object { 
                if ($_.ToString().StartsWith("ERROR: ")) {
                  if ($errorString.Length -gt 0) { $errorString += "`n" }
                  $bError = $true
                  $errDetector = $true
                  $bWarning = $false
                }
                if ($_.ToString().StartsWith("WARNING: ")) {
                  if ($warningString.Length -gt 0) { $warningString += "`n" }  
                  $bWarning = $true
                  $warDetector = $true
                  $bError = $false
                }
                if ($bError) {
                  $errorString += $_.ToString() + " "
                }
                if ($bWarning) {
                  $warningString += $_.ToString() + " "
                }
              }

              # Output errors and warings
              if ($errDetector) {
                Write-Output "Following Errors detected:`r`n`t$errorString"
              }
              if ($warDetector) {
                Write-Output "Following Warnings detected:`r`n`t$warningString"
              }

              # Need to retry only when ERROR detected; no need to retry in the case of WARNINGS only in the output stream
              if ($errDetector -or ($resultExitCode -ne 0)) {
                if ($retrycount -ge $Retries) {
                  $myMsg = "Failed to successfully execute command with all retry commands exhausted"
                  Throw $myMsg
                } else {
                  Write-Output "`r`n`tRetrying in '$SecondsDelay' seconds"
                  Start-Sleep $SecondsDelay
                  $retrycount++
                  Write-Output "---------------------RETRY #($retrycount)-----------------------------------"
                  continue
                }
              }
            }
            Write-Output "Command succeeded"
            $completed = $true
          }
        } catch {
          Write-Error "[ERR] Error happened while deleting batch to storage account. Details: '$_'"
        } finally {
          $Error.Clear()
        }

        # -----------------------------------------------------

        #Add Annotation
        try {
          $Error.Clear()
          [Bool]$completed = $false          
          $command = "(az storage account show --name `"${{ env.azure_bucket }}`" --query `"primaryEndpoints.web`") 2>&1"
          Write-Output "Executing command: '$command'"
          $result = Invoke-Expression -Command $command
          if ($LastExitCode -eq 0) {
            Write-Output "Command succeeded"
            $baseurl = $result
            $baseurl = $baseurl.trim("`"")
            $uri = "${{ env.build_path }}".trimStart("/")
            $url = $baseurl + $uri
            Write-Output "::notice title=site url::$url"    
          } else {
            $myMsg = "Failed to query base URL. Command exit code '$LastExitCode' and result: '$result'"
            Throw $myMsg            
          }
        } catch {
          Write-Error "[ERR] Error happened while adding annotation. Details: '$_'"
        } finally {
          $Error.Clear()
        }
      shell: pwsh 

    - name: Remove network rule from storage account
      if: always()
      run: |
        try {
          $Error.Clear()
          [Int32]$Retries = 24
          [Int32]$SecondsDelay = 10
          [Int32]$retrycount = 0
          [Bool]$completed = $false          
          $command = "(az storage account network-rule remove --account-name `"${{ env.azure_bucket }}`" --ip-address `"${{ steps.ip.outputs.address }}`") 2>&1"
          Write-Output "Executing command: '$command'"

          while (-not $completed) {
            $Error.Clear()
            $result = Invoke-Expression -Command $command
            if ($LastExitCode -ne 0) {
              if ($retrycount -ge $Retries) {
                $myMsg = "Command exit code '$LastExitCode' and result: '$result'"
                Throw $myMsg
              } else {
                $myMsg = "Command exit code '$LastExitCode' and result: '$result'"
                Write-Output "$myMsg`r`n`tRetrying in '$SecondsDelay' seconds"
                Start-Sleep $SecondsDelay
                $retrycount++
                Write-Output "---------------------RETRY #($retrycount)-----------------------------------"
                continue
              }
            } else {
              Write-Output "Command succeeded"
              $completed = $true
            } 
          }
        } catch {
          Write-Error "[ERR] Error happened while removing network rule from storage account. Details: '$_'"
        } finally {
          $Error.Clear()
        }
      shell: pwsh 
    
    - name: Azure logout
      if: always()
      run: az logout
      shell: bash
